













module RaceEventProject::AfterRoot
{
    #include "../quick-share/icon.ad";
	
	// --- VARIABLES FOR SYNTH REWARD ---
    static prize_car_code = nil;
    static prize_car_color = nil;
    // -------------------------------------

    
    // COURSES 
    // There is probably a better and more optimized way of doing this, but it works for now
    static six_car_courses = [
        "akasaka", "apricot", "autumn", "deepforest", "fisco", "fisco_old",
        "grandvalley", "grandvalley_east", "highspeedring", "hongkong",
        "infineon", "infineon_nascar", "kashiwa", "laguna", "midfield",
        "mini", "montecarlo", "motegi", "motegi_east", "motegi_west",
        "new_fisco", "new_fisco_gt", "newyork", "nurburgring", "oval",
        "paris_tarmac", "route5", "route5_club", "sarthe", "sarthe_old",
        "seattle", "seoul", "suzuka", "suzuka_east", "suzuka_west",
        "tt_valencia", "trialmt", "tsukuba", "yosemite"
    ];

    static rally_dirt_courses = [ "swiss", "tahiti", "tsukuba_dirt", "cathedral", "colorado", "grandcanyon" ];
    static rally_snow_courses = [ "ice", "chamonix" ];
    static rally_road_courses = [
        //"20r60r",
        "akasaka",
        "apricot",
        "assisi",
        "autumn",
        "capri",
        "deepforest",
        "fisco",
        "fisco_old",
        "grandvalley",
        "grandvalley_east",
        "highspeedring",
        "hongkong",
        "infineon",
        "infineon_nascar",
        "kashiwa",
        "laguna",
        "midfield",
        "mini",
        "montecarlo",
        "motegi",
        "motegi_east",
        "motegi_west",
        "new_fisco",
        "new_fisco_gt",
        "newyork",
        "nurburgring",
        "oval",
        "paris_rally",
        "paris_tarmac",
        //"r_20r60r",
        "r_akasaka",
        "r_apricot",
        "r_assisi",
        "r_autumn",
        "r_capri",
        "r_deepforest",
        "r_grandvalley",
        "r_grandvalley_east",
        "r_highspeedring",
        "r_hongkong",
        "r_kashiwa",
        "r_midfield",
        "r_mini",
        "r_newyork",
        "r_paris_rally",
        "r_paris_tarmac",
        "r_route5",
        "r_route5_club",
        "r_seattle",
        "r_seoul",
        "r_trialmt",
        "r_yosemite",
        "route5",
        "route5_club",
        "sarthe24",
        "sarthe_old24",
        "seattle",
        "seoul",
        "suzuka",
        "suzuka_east",
        "suzuka_west",
        //"testcourse",
        "trialmt",
        "tsukuba",
        //"tt_valencia",
        "yosemite"
    ];

function getRandomCourse(context, use_seed)
{
    var course_array = [];
    import main::game;
    var race = main::menu::MRaceData(game.race_code);

    switch (race.getNeedTire())
    {
        case 3: 
            course_array = RaceEventProject::AfterRoot::rally_dirt_courses;
            break;
        case 4: 
            course_array = RaceEventProject::AfterRoot::rally_snow_courses;
            break;
        default:
            if (race.entry_num < 6)
                course_array = RaceEventProject::AfterRoot::rally_road_courses;
            else
                course_array = RaceEventProject::AfterRoot::six_car_courses;
            break;
    }

    if (course_array.size == 0)
    {
        return "clubman"; 
    }
    else
    {
        var rnd = -1;
        if (use_seed)
            rnd = main::menu::MRandom::GetValue(0, course_array.size, fnv1a(main::game.username + game.race_code));
        else 
            rnd = main::menu::MRandom::GetValue(0, course_array.size);
            
        return course_array[rnd];
    }
}

    var quick_work = main::menu::MQuickWork();
    for (var i = 1; i <= quick_work.numberOfEntries; i++)
    {
        var widget = ROOT["Grid" + i];
        setMoveActor(widget, 640 + (392 * 2 * i), 0, 0.15);
    }

    function onInitialize(context)
    {
        var quick_work = main::menu::MQuickWork();

        for (var i = 0; i < quick_work.numberOfEntries; i++)
        {
            ROOT["Grid" + (i + 1)]["CarName"].text = quick_work.getGridCarName(i);
            ROOT["Grid" + (i + 1)]["CarName"].abbreviate();
            ROOT["Grid" + (i + 1)]["ColorChip"].setColor(quick_work.getColorChipInfo(i));
            ROOT["Grid" + (i + 1)]["Time"].text = main::menu::MUtility::GetTimeString(quick_work.getGridTime(i));
        }

        for (var i = 1; i <= quick_work.numberOfEntries; i++)
        {
            var widget = ROOT["Grid" + i];
            widget.actor.out = true;
            widget.actor.warp();
            widget.actor.out = false;
        }

        for (var i = quick_work.numberOfEntries + 1; i <= 6; i++)
            ROOT["Grid" + i].visible = false;

        if (quick_work.playerGridNumber >= 0)
        {
            var gnum = quick_work.playerGridNumber + 1;
            ROOT["Grid" + gnum]["CarName"].color = ROOT::Hidden::MyGridColor.color;
            ROOT["Grid" + gnum]["GridNumber"].color = ROOT::Hidden::MyGridColor.color;
            ROOT["Grid" + gnum]["Time"].color = ROOT::Hidden::MyGridColor.color;
        }

        var race_code = main::menu::MQuickWork().raceLabel;

        if (race_code == "family")
            GridTitle_text.text = context.translate(ROOT, "EventName", race_code);
        else
            GridTitle_text.text = getEventNameByRaceCode(context, ROOT, race_code);

        GridTitle_text.adjustScale();

        main::sound.startStreamEx("pcm", "default_quick", -1, 1, main::game.option.menu_bgm_volume);
		
        var race_code = main::menu::MQuickWork().raceLabel;

        
        // We display the button ONLY in generated races
        // and only if there is no car prize waiting to be redeemed.
        if (race_code == "eventgen_0000" && prize_car_code == nil)
            ROOT::Buttons["TestButton"].visible = true;
        else
            ROOT::Buttons["TestButton"].visible = false;

         
        
        // // Now that the game knows exactly how many buttons are present 
        setIconPosition(context);
        setDefaultIconFocus(context);
    }

	function set_next_start_project()
    {
        main::game.next_menu_project = main::game.major_menu_project;
        // Where the magic happens with NEXT_MENU_ARG
        // If there is a prize waiting, we write it on the "ticket" for the next menu.
        if (prize_car_code != nil)
        {
            
            main::game.next_menu_arg = "@" + prize_car_code;
            
            prize_car_code = nil;
            prize_car_color = nil;
        }
        // --------------------------------------------
    }

    static icon_name_tbl = [
        "Start",
        "Replay",
        "SaveReplay",
        "Option",
        "Exit",
        "TestButton",
    ];

    function setIconPosition(context)
    {
        var max = icon_name_tbl.size;
        var num = 0;

        for (var i = 0; i < max; i++)
        {
            if (ROOT::Buttons[icon_name_tbl[i]].visible == true)
                num++;
        }

        var screen_w = 640;
        var icon_w = 72;
        var space = 4;

        var st = ((screen_w - ((num * icon_w))) - (space * (num - 1))) / 2;
        var c = 0;
        
        for (var i = 0; i < max; i++)
        {
            if (ROOT::Buttons[icon_name_tbl[i]].visible == true)
            {
                ROOT::Buttons[icon_name_tbl[i]].x = st + ((icon_w + space) * c);
                c++;
            }
        }
    }

    function onCancel(context, event, item)
    {
        main::sound.play("cancel");
        main::sound.stopStream();
        var quick_work = main::menu::MQuickWork();
        quick_work.selectedCommand = "COMMAND_EXIT";
        
        context.transition.panOut(context);
        context.transition.syncOut(context);

        set_next_start_project();
        context.finish();
        return STATE_YIELD;
    }
}

module RaceEventProject::AfterRoot::Buttons::Start
{
    function onActivate(context)
    {
        main::sound.play("ok");
        main::sound.stopStream();

        var quick_work = main::menu::MQuickWork();
        quick_work.selectedCommand = "COMMAND_START";
        quick_work.cursorPosition = getIconIndex(context, "Start");

        context.transition.panOut(context);
        context.transition.syncOut(context);
        context.finish();

        return STATE_YIELD;
    }
}

module RaceEventProject::AfterRoot::Buttons::Replay
{
    function onActivate(context)
    {
        main::sound.play("ok");
        main::sound.stopStream();

        var quick_work = main::menu::MQuickWork();
        quick_work.selectedCommand = "COMMAND_REPLAY";
        quick_work.cursorPosition = getIconIndex(context, "Replay");

        context.transition.panOut(context);
        context.transition.syncOut(context);
        context.finish();

        return STATE_YIELD;
    }
}

module RaceEventProject::AfterRoot::Buttons::SaveReplay
{
    function onActivate(context)
    {
        main::sound.play("ok");
        main::sound.stopStream();

        var quick_work = main::menu::MQuickWork();
        quick_work.selectedCommand = "COMMAND_SAVE_REPLAY";
        quick_work.cursorPosition = getIconIndex(context, "SaveReplay");

        context.transition.panOut(context);
        context.transition.syncOut(context);
        context.finish();

        return STATE_YIELD;
    }
}

module RaceEventProject::AfterRoot::Buttons::Option
{
    function onActivate(context)
    {
        main::sound.play("ok");
        main::sound.stopStream();

        var quick_work = main::menu::MQuickWork();
        quick_work.selectedCommand = "COMMAND_OPTION";
        quick_work.cursorPosition = getIconIndex(context, "Option");

        context.transition.panOut(context);
        context.transition.syncOut(context);
        set_next_start_project();
        context.finish();

        return STATE_YIELD;
    }
}

module RaceEventProject::AfterRoot::Buttons::Exit
{
    function onActivate(context)
    {
        main::sound.play("ok");
        main::sound.stopStream();

        var quick_work = main::menu::MQuickWork();
        quick_work.selectedCommand = "COMMAND_EXIT";
        
        context.transition.panOut(context);
        context.transition.syncOut(context);

        set_next_start_project();
        context.finish();
        return STATE_YIELD;
    }
}

module RaceEventProject::AfterRoot::Buttons::TestButton
{
    function onActivate(context)
    {
        import main::game;
        main::sound.play("ok");
        main::sound.stopStream();

        var new_course_code = RaceEventProject::AfterRoot::getRandomCourse(context, false);

        if (new_course_code != nil)
        {
            main::game.course_code = new_course_code;
            
            
            // This doesn't really work, but I'm keeping it anyway
            var current_vol = main::game.option.menu_bgm_volume;
            
            // Same as above
            main::game.option.menu_bgm_volume = 0.0;
            
            // Same as above
            main::game.option.apply(); 
            
            // Same as above
            main::game.next_menu_arg = "autoplay_next_race:" + current_vol.toString();
            // ---------------------------------------

            main::game.next_menu_project = main::game.major_menu_project;

            var quick_work = main::menu::MQuickWork();
            quick_work.selectedCommand = "COMMAND_EXIT";
            
            context.transition.panOut(context);
            context.transition.syncOut(context);
            context.finish();
        }
        else
        {
            openConfirmDialog(context, 4, "Error: No course found");
        }

        return STATE_YIELD;
    }
}
